"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const graphql_compose_1 = require("graphql-compose");
const get_field_type_meta_1 = __importDefault(require("./get-field-type-meta"));
const get_cypher_meta_1 = __importDefault(require("./get-cypher-meta"));
const get_alias_meta_1 = __importDefault(require("./get-alias-meta"));
const get_auth_1 = __importDefault(require("./get-auth"));
const get_relationship_meta_1 = __importDefault(require("./get-relationship-meta"));
const parse_value_node_1 = __importDefault(require("./parse-value-node"));
function getObjFieldMeta({ obj, objects, interfaces, scalars, unions, enums, }) {
    var _a;
    return (_a = obj === null || obj === void 0 ? void 0 : obj.fields) === null || _a === void 0 ? void 0 : _a.reduce((res, field) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
        if ((_a = field === null || field === void 0 ? void 0 : field.directives) === null || _a === void 0 ? void 0 : _a.some((x) => x.name.value === "private")) {
            return res;
        }
        const relationshipMeta = get_relationship_meta_1.default(field);
        const cypherMeta = get_cypher_meta_1.default(field);
        const typeMeta = get_field_type_meta_1.default(field);
        const authDirective = (_b = field.directives) === null || _b === void 0 ? void 0 : _b.find((x) => x.name.value === "auth");
        const idDirective = (_c = field === null || field === void 0 ? void 0 : field.directives) === null || _c === void 0 ? void 0 : _c.find((x) => x.name.value === "id");
        const defaultDirective = (_d = field === null || field === void 0 ? void 0 : field.directives) === null || _d === void 0 ? void 0 : _d.find((x) => x.name.value === "default");
        const coalesceDirective = (_e = field === null || field === void 0 ? void 0 : field.directives) === null || _e === void 0 ? void 0 : _e.find((x) => x.name.value === "coalesce");
        const timestampDirective = (_f = field === null || field === void 0 ? void 0 : field.directives) === null || _f === void 0 ? void 0 : _f.find((x) => x.name.value === "timestamp");
        const aliasDirective = (_g = field === null || field === void 0 ? void 0 : field.directives) === null || _g === void 0 ? void 0 : _g.find((x) => x.name.value === "alias");
        const fieldInterface = interfaces.find((x) => x.name.value === typeMeta.name);
        const fieldUnion = unions.find((x) => x.name.value === typeMeta.name);
        const fieldScalar = scalars.find((x) => x.name.value === typeMeta.name);
        const fieldEnum = enums.find((x) => x.name.value === typeMeta.name);
        const fieldObject = objects.find((x) => x.name.value === typeMeta.name);
        const baseField = Object.assign(Object.assign({ fieldName: field.name.value, dbPropertyName: field.name.value, typeMeta, otherDirectives: (field.directives || []).filter((x) => ![
                "relationship",
                "cypher",
                "id",
                "auth",
                "readonly",
                "writeonly",
                "ignore",
                "default",
                "coalesce",
                "timestamp",
                "alias",
            ].includes(x.name.value)), arguments: [...(field.arguments || [])] }, (authDirective ? { auth: get_auth_1.default(authDirective) } : {})), { description: (_h = field.description) === null || _h === void 0 ? void 0 : _h.value, readonly: (_j = field === null || field === void 0 ? void 0 : field.directives) === null || _j === void 0 ? void 0 : _j.some((d) => d.name.value === "readonly"), writeonly: (_k = field === null || field === void 0 ? void 0 : field.directives) === null || _k === void 0 ? void 0 : _k.some((d) => d.name.value === "writeonly") });
        if (aliasDirective) {
            const aliasMeta = get_alias_meta_1.default(field);
            if (aliasMeta) {
                baseField.dbPropertyName = aliasMeta.property;
            }
        }
        if (relationshipMeta) {
            if (fieldInterface) {
                throw new Error("cannot have interface on relationship");
            }
            if (authDirective) {
                throw new Error("cannot have auth directive on a relationship");
            }
            if (defaultDirective) {
                throw new Error("@default directive can only be used on primitive type fields");
            }
            if (coalesceDirective) {
                throw new Error("@coalesce directive can only be used on primitive type fields");
            }
            if (aliasDirective) {
                throw new Error("@alias directive cannot be used on relationship fields");
            }
            const relationField = Object.assign(Object.assign({}, baseField), relationshipMeta);
            if (fieldUnion) {
                const nodes = [];
                (_l = fieldUnion.types) === null || _l === void 0 ? void 0 : _l.forEach((type) => {
                    nodes.push(type.name.value);
                });
                const unionField = Object.assign(Object.assign({}, baseField), { nodes });
                relationField.union = unionField;
            }
            res.relationFields.push(relationField);
            if (obj.kind !== "InterfaceTypeDefinition") {
                const connectionTypeName = `${obj.name.value}${graphql_compose_1.upperFirst(`${baseField.fieldName}Connection`)}`;
                const relationshipTypeName = `${obj.name.value}${graphql_compose_1.upperFirst(`${baseField.fieldName}Relationship`)}`;
                const connectionField = {
                    fieldName: `${baseField.fieldName}Connection`,
                    relationshipTypeName,
                    typeMeta: {
                        name: connectionTypeName,
                        required: true,
                        pretty: `${connectionTypeName}!`,
                        input: {
                            where: {
                                type: `${connectionTypeName}Where`,
                                pretty: `${connectionTypeName}Where`,
                            },
                            create: {
                                type: "",
                                pretty: "",
                            },
                            update: {
                                type: "",
                                pretty: "",
                            },
                        },
                    },
                    otherDirectives: [],
                    arguments: [...(field.arguments || [])],
                    description: (_m = field.description) === null || _m === void 0 ? void 0 : _m.value,
                    relationship: relationField,
                };
                res.connectionFields.push(connectionField);
            }
        }
        else if (cypherMeta) {
            if (defaultDirective) {
                throw new Error("@default directive can only be used on primitive type fields");
            }
            if (coalesceDirective) {
                throw new Error("@coalesce directive can only be used on primitive type fields");
            }
            if (aliasDirective) {
                throw new Error("@alias directive cannot be used on cypher fields");
            }
            const cypherField = Object.assign(Object.assign({}, baseField), cypherMeta);
            res.cypherFields.push(cypherField);
        }
        else if (fieldScalar) {
            if (defaultDirective) {
                throw new Error("@default directive can only be used on primitive type fields");
            }
            const scalarField = Object.assign({}, baseField);
            res.scalarFields.push(scalarField);
        }
        else if (fieldEnum) {
            if (defaultDirective) {
                throw new Error("@default directive can only be used on primitive type fields");
            }
            if (coalesceDirective) {
                throw new Error("@coalesce directive can only be used on primitive type fields");
            }
            const enumField = Object.assign({ kind: "Enum" }, baseField);
            res.enumFields.push(enumField);
        }
        else if (fieldUnion) {
            if (defaultDirective) {
                throw new Error("@default directive can only be used on primitive type fields");
            }
            if (coalesceDirective) {
                throw new Error("@coalesce directive can only be used on primitive type fields");
            }
            const unionField = Object.assign({}, baseField);
            res.unionFields.push(unionField);
        }
        else if (fieldInterface) {
            if (defaultDirective) {
                throw new Error("@default directive can only be used on primitive type fields");
            }
            if (coalesceDirective) {
                throw new Error("@coalesce directive can only be used on primitive type fields");
            }
            const interfaceField = Object.assign({}, baseField);
            res.interfaceFields.push(interfaceField);
        }
        else if (fieldObject) {
            if (defaultDirective) {
                throw new Error("@default directive can only be used on primitive type fields");
            }
            if (coalesceDirective) {
                throw new Error("@coalesce directive can only be used on primitive type fields");
            }
            const objectField = Object.assign({}, baseField);
            res.objectFields.push(objectField);
        }
        else if ((_o = field.directives) === null || _o === void 0 ? void 0 : _o.some((d) => d.name.value === "ignore")) {
            res.ignoredFields.push(baseField);
        }
        else {
            // eslint-disable-next-line no-lonely-if
            if (["DateTime", "Date", "Time", "LocalDateTime", "LocalTime"].includes(typeMeta.name)) {
                const temporalField = Object.assign({}, baseField);
                if (timestampDirective) {
                    if (baseField.typeMeta.array) {
                        throw new Error("cannot auto-generate an array");
                    }
                    if (!["DateTime", "Time"].includes(typeMeta.name)) {
                        throw new Error("Cannot timestamp temporal fields lacking time zone information");
                    }
                    const operations = (_q = (_p = timestampDirective === null || timestampDirective === void 0 ? void 0 : timestampDirective.arguments) === null || _p === void 0 ? void 0 : _p.find((x) => x.name.value === "operations")) === null || _q === void 0 ? void 0 : _q.value;
                    const timestamps = operations
                        ? operations === null || operations === void 0 ? void 0 : operations.values.map((x) => parse_value_node_1.default(x))
                        : ["CREATE", "UPDATE"];
                    temporalField.timestamps = timestamps;
                }
                if (defaultDirective) {
                    const value = (_s = (_r = defaultDirective.arguments) === null || _r === void 0 ? void 0 : _r.find((a) => a.name.value === "value")) === null || _s === void 0 ? void 0 : _s.value;
                    if (Number.isNaN(Date.parse(value.value))) {
                        throw new Error(`Default value for ${obj.name.value}.${temporalField.fieldName} is not a valid DateTime`);
                    }
                    temporalField.defaultValue = value.value;
                }
                if (coalesceDirective) {
                    throw new Error("@coalesce is not supported by DateTime fields at this time");
                }
                res.temporalFields.push(temporalField);
            }
            else if (["Point", "CartesianPoint"].includes(typeMeta.name)) {
                if (defaultDirective) {
                    throw new Error("@default directive can only be used on primitive type fields");
                }
                if (coalesceDirective) {
                    throw new Error("@coalesce directive can only be used on primitive type fields");
                }
                const pointField = Object.assign({}, baseField);
                res.pointFields.push(pointField);
            }
            else {
                const primitiveField = Object.assign({}, baseField);
                if (idDirective) {
                    const autogenerate = (_t = idDirective.arguments) === null || _t === void 0 ? void 0 : _t.find((a) => a.name.value === "autogenerate");
                    if (!autogenerate || autogenerate.value.value) {
                        if (baseField.typeMeta.name !== "ID") {
                            throw new Error("cannot auto-generate a non ID field");
                        }
                        if (baseField.typeMeta.array) {
                            throw new Error("cannot auto-generate an array");
                        }
                        primitiveField.autogenerate = true;
                    }
                }
                if (defaultDirective) {
                    const value = (_v = (_u = defaultDirective.arguments) === null || _u === void 0 ? void 0 : _u.find((a) => a.name.value === "value")) === null || _v === void 0 ? void 0 : _v.value;
                    const checkKind = (kind) => {
                        if ((value === null || value === void 0 ? void 0 : value.kind) !== kind) {
                            throw new Error(`Default value for ${obj.name.value}.${primitiveField.fieldName} does not have matching type ${primitiveField.typeMeta.name}`);
                        }
                    };
                    switch (baseField.typeMeta.name) {
                        case "ID":
                        case "String":
                            checkKind(graphql_1.Kind.STRING);
                            primitiveField.defaultValue = value.value;
                            break;
                        case "Boolean":
                            checkKind(graphql_1.Kind.BOOLEAN);
                            primitiveField.defaultValue = value.value;
                            break;
                        case "Int":
                            checkKind(graphql_1.Kind.INT);
                            primitiveField.defaultValue = parseInt(value.value, 10);
                            break;
                        case "Float":
                            checkKind(graphql_1.Kind.FLOAT);
                            primitiveField.defaultValue = parseFloat(value.value);
                            break;
                        default:
                            throw new Error("@default directive can only be used on types: Int | Float | String | Boolean | ID | DateTime");
                    }
                }
                if (coalesceDirective) {
                    const value = (_x = (_w = coalesceDirective.arguments) === null || _w === void 0 ? void 0 : _w.find((a) => a.name.value === "value")) === null || _x === void 0 ? void 0 : _x.value;
                    const checkKind = (kind) => {
                        if ((value === null || value === void 0 ? void 0 : value.kind) !== kind) {
                            throw new Error(`coalesce() value for ${obj.name.value}.${primitiveField.fieldName} does not have matching type ${primitiveField.typeMeta.name}`);
                        }
                    };
                    switch (baseField.typeMeta.name) {
                        case "ID":
                        case "String":
                            checkKind(graphql_1.Kind.STRING);
                            primitiveField.coalesceValue = `"${value.value}"`;
                            break;
                        case "Boolean":
                            checkKind(graphql_1.Kind.BOOLEAN);
                            primitiveField.coalesceValue = value.value;
                            break;
                        case "Int":
                            checkKind(graphql_1.Kind.INT);
                            primitiveField.coalesceValue = parseInt(value.value, 10);
                            break;
                        case "Float":
                            checkKind(graphql_1.Kind.FLOAT);
                            primitiveField.coalesceValue = parseFloat(value.value);
                            break;
                        default:
                            throw new Error("@coalesce directive can only be used on types: Int | Float | String | Boolean | ID | DateTime");
                    }
                }
                res.primitiveFields.push(primitiveField);
            }
        }
        return res;
    }, {
        relationFields: [],
        connectionFields: [],
        primitiveFields: [],
        cypherFields: [],
        scalarFields: [],
        enumFields: [],
        unionFields: [],
        interfaceFields: [],
        objectFields: [],
        temporalFields: [],
        pointFields: [],
        ignoredFields: [],
    });
}
exports.default = getObjFieldMeta;
//# sourceMappingURL=get-obj-field-meta.js.map
"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const camelcase_1 = __importDefault(require("camelcase"));
const graphql_1 = require("graphql");
const graphql_compose_1 = require("graphql-compose");
const make_augmented_schema_1 = __importDefault(require("./make-augmented-schema"));
const classes_1 = require("../classes");
const constants = __importStar(require("../constants"));
describe("makeAugmentedSchema", () => {
    test("should be a function", () => {
        expect(make_augmented_schema_1.default).toBeInstanceOf(Function);
    });
    test("should return the correct schema", () => {
        const typeDefs = `
            type Actor {
                name: String
                movies: [Movie] @relationship(type: "ACTED_IN", direction: OUT)
            }

            type Movie {
                title: String!
                actors: [Actor] @relationship(type: "ACTED_IN", direction: IN)
            }
        `;
        const neoSchema = make_augmented_schema_1.default({ typeDefs });
        const document = graphql_1.parse(graphql_1.printSchema(neoSchema.schema));
        const queryObject = document.definitions.find((x) => x.kind === "ObjectTypeDefinition" && x.name.value === "Query");
        ["Actor", "Movie"].forEach((type) => {
            var _a;
            const node = neoSchema.nodes.find((x) => x.name === type);
            expect(node).toBeInstanceOf(classes_1.Node);
            const nodeObject = document.definitions.find((x) => x.kind === "ObjectTypeDefinition" && x.name.value === type);
            expect(nodeObject).toBeTruthy();
            // Find
            const nodeFindQuery = (_a = queryObject.fields) === null || _a === void 0 ? void 0 : _a.find((x) => x.name.value === graphql_compose_1.pluralize(camelcase_1.default(type)));
            const nodeFindQueryType = (nodeFindQuery === null || nodeFindQuery === void 0 ? void 0 : nodeFindQuery.type).type
                .type.type;
            expect(nodeFindQueryType.name.value).toEqual(type);
            // Options
            const options = document.definitions.find((x) => x.kind === "InputObjectTypeDefinition" && x.name.value === `${type}Options`);
            expect(options).toBeTruthy();
            // Where
            const where = document.definitions.find((x) => x.kind === "InputObjectTypeDefinition" && x.name.value === `${type}Where`);
            expect(where).toBeTruthy();
            // SORT
            const sort = document.definitions.find((x) => x.kind === "InputObjectTypeDefinition" && x.name.value === `${type}Sort`);
            expect(sort).toBeTruthy();
        });
    });
    test("should throw cannot have interface on relationship", () => {
        const typeDefs = `
                interface Node {
                    id: ID
                }

                type Movie {
                    title: String!
                    nodes: [Node] @relationship(type: "NODE", direction: IN)
                }
            `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("cannot have interface on relationship");
    });
    test("should throw cannot auto-generate a non ID field", () => {
        const typeDefs = `
            type Movie  {
                name: String! @id
            }
        `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("cannot auto-generate a non ID field");
    });
    test("should throw cannot auto-generate an array", () => {
        const typeDefs = `
                type Movie  {
                    name: [ID] @id
                }
            `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("cannot auto-generate an array");
    });
    test("should throw cannot timestamp on array of DateTime", () => {
        const typeDefs = `
                type Movie  {
                    name: [DateTime] @timestamp(operations: [CREATE])
                }
            `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("cannot auto-generate an array");
    });
    test("should throw cannot have auth directive on a relationship", () => {
        const typeDefs = `
                type Movie {
                    movie: Movie @relationship(type: "NODE", direction: OUT) @auth(rules: [{operations: [CREATE]}])
                }
            `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("cannot have auth directive on a relationship");
    });
    describe("REGEX", () => {
        test("should remove the MATCHES filter by default", () => {
            var _a;
            const typeDefs = `
                    type Movie {
                        name: String
                    }
                `;
            const neoSchema = make_augmented_schema_1.default({ typeDefs });
            const document = graphql_1.parse(graphql_1.printSchema(neoSchema.schema));
            const nodeWhereInput = document.definitions.find((x) => x.kind === "InputObjectTypeDefinition" && x.name.value === "MovieWhere");
            const matchesField = (_a = nodeWhereInput.fields) === null || _a === void 0 ? void 0 : _a.find((x) => x.name.value.endsWith("_MATCHES"));
            expect(matchesField).toBeUndefined();
        });
        test("should add the MATCHES filter when NEO4J_GRAPHQL_ENABLE_REGEX is set", () => {
            var _a;
            const typeDefs = `
                    type User {
                        name: String
                    }
                `;
            const neoSchema = make_augmented_schema_1.default({ typeDefs }, { enableRegex: true });
            const document = graphql_1.parse(graphql_1.printSchema(neoSchema.schema));
            const nodeWhereInput = document.definitions.find((x) => x.kind === "InputObjectTypeDefinition" && x.name.value === "UserWhere");
            const matchesField = (_a = nodeWhereInput.fields) === null || _a === void 0 ? void 0 : _a.find((x) => x.name.value.endsWith("_MATCHES"));
            expect(matchesField).not.toBeUndefined();
        });
    });
    describe("issues", () => {
        test("158", () => {
            // https://github.com/neo4j/graphql/issues/158
            const typeDefs = `
                type Movie {
                    createdAt: DateTime
                }

                type Query {
                  movies: [Movie] @cypher(statement: "")
                }
            `;
            const neoSchema = make_augmented_schema_1.default({ typeDefs });
            const document = graphql_1.parse(graphql_1.printSchema(neoSchema.schema));
            // make sure the schema constructs
            expect(document.kind).toEqual("Document");
        });
    });
    test("should throw error if @auth is used on relationship properties interface", () => {
        const typeDefs = `
            type Movie {
                actors: Actor @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
            }

            type Actor {
                name: String
            }

            interface ActedIn @auth(rules: [{ operations: [CREATE], roles: ["admin"] }]) {
                screenTime: Int
            }
        `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("Cannot have @auth directive on relationship properties interface");
    });
    test("should throw error if @cypher is used on relationship properties interface", () => {
        const typeDefs = `
            type Movie {
                actors: Actor @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
            }

            type Actor {
                name: String
            }

            interface ActedIn @cypher(statement: "RETURN rand()") {
                screenTime: Int
            }
        `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow('Directive "@cypher" may not be used on INTERFACE.');
    });
    test("should throw error if @auth is used on relationship property", () => {
        const typeDefs = `
            type Movie {
                actors: Actor @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
            }

            type Actor {
                name: String
            }

            interface ActedIn {
                screenTime: Int @auth(rules: [{ operations: [CREATE], roles: ["admin"] }])
            }
        `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("Cannot have @auth directive on relationship property");
    });
    test("should throw error if @relationship is used on relationship property", () => {
        const typeDefs = `
            type Movie {
                actors: Actor @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
            }

            type Actor {
                name: String
            }

            interface ActedIn {
                actors: Actor @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
            }
        `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("Cannot have @relationship directive on relationship property");
    });
    test("should throw error if @cypher is used on relationship property", () => {
        const typeDefs = `
            type Movie {
                actors: Actor @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
            }

            type Actor {
                name: String
            }

            interface ActedIn {
                id: ID @cypher(statement: "RETURN id(this)")
                roles: [String]
            }
        `;
        expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow("Cannot have @cypher directive on relationship property");
    });
    describe("Reserved Names", () => {
        describe("Node", () => {
            test("should throw when using PageInfo as node name", () => {
                const typeDefs = `
                    type PageInfo {
                        id: ID
                    }
                `;
                expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow(constants.RESERVED_TYPE_NAMES.find((x) => x[0] === "PageInfo")[1]);
            });
            test("should throw when using Connection in a node name", () => {
                const typeDefs = `
                    type NodeConnection {
                        id: ID
                    }
                `;
                expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow(constants.RESERVED_TYPE_NAMES.find((x) => x[0] === "Connection")[1]);
            });
            test("should throw when using Node as node name", () => {
                const typeDefs = `
                    type Node {
                        id: ID
                    }
                `;
                expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow(constants.RESERVED_TYPE_NAMES.find((x) => x[0] === "Node")[1]);
            });
        });
        describe("Interface", () => {
            test("should throw when using PageInfo as relationship properties interface name", () => {
                const typeDefs = `
                    type Movie {
                        id: ID
                        actors: [Actor] @relationship(type: "ACTED_IN", direction: OUT, properties: "PageInfo")
                    }

                    interface PageInfo {
                        screenTime: Int
                    }

                    type Actor {
                        name: String
                    }
                `;
                expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow(constants.RESERVED_TYPE_NAMES.find((x) => x[0] === "PageInfo")[1]);
            });
            test("should throw when using Connection in a properties interface name", () => {
                const typeDefs = `
                    type Movie {
                        id: ID
                        actors: [Actor] @relationship(type: "ACTED_IN", direction: OUT, properties: "NodeConnection")
                    }

                    interface NodeConnection {
                        screenTime: Int
                    }

                    type Actor {
                        name: String
                    }
                `;
                expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow(constants.RESERVED_TYPE_NAMES.find((x) => x[0] === "Connection")[1]);
            });
            test("should throw when using Node as relationship properties interface name", () => {
                const typeDefs = `
                    type Movie {
                        id: ID
                        actors: [Actor] @relationship(type: "ACTED_IN", direction: OUT, properties: "Node")
                    }

                    interface Node {
                        screenTime: Int
                    }

                    type Actor {
                        name: String
                    }
                `;
                expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow(constants.RESERVED_TYPE_NAMES.find((x) => x[0] === "Node")[1]);
            });
            describe("Fields", () => {
                test("should throw when using 'node' as a relationship property", () => {
                    const typeDefs = `
                        type Movie {
                            id: ID
                            actors: [Actor] @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
                        }

                        interface ActedIn {
                            node: ID
                        }

                        type Actor {
                            name: String
                        }
                    `;
                    expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow(constants.RESERVED_INTERFACE_FIELDS.find((x) => x[0] === "node")[1]);
                });
                test("should throw when using 'cursor' as a relationship property", () => {
                    const typeDefs = `
                        type Movie {
                            id: ID
                            actors: [Actor] @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
                        }

                        interface ActedIn {
                            cursor: ID
                        }

                        type Actor {
                            name: String
                        }
                    `;
                    expect(() => make_augmented_schema_1.default({ typeDefs })).toThrow(constants.RESERVED_INTERFACE_FIELDS.find((x) => x[0] === "cursor")[1]);
                });
            });
        });
    });
});
//# sourceMappingURL=make-augmented-schema.test.js.map
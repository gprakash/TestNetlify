"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const merge_1 = require("@graphql-tools/merge");
const schema_1 = require("@graphql-tools/schema");
const utils_1 = require("@graphql-tools/utils");
const graphql_1 = require("graphql");
const graphql_compose_1 = require("graphql-compose");
const pluralize_1 = __importDefault(require("pluralize"));
const classes_1 = require("../classes");
const get_auth_1 = __importDefault(require("./get-auth"));
const resolvers_1 = require("./resolvers");
const Scalars = __importStar(require("./scalars"));
const parse_exclude_directive_1 = __importDefault(require("./parse-exclude-directive"));
const get_custom_resolvers_1 = __importDefault(require("./get-custom-resolvers"));
const get_obj_field_meta_1 = __importDefault(require("./get-obj-field-meta"));
const point = __importStar(require("./point"));
const to_compose_1 = require("./to-compose");
const Relationship_1 = __importDefault(require("../classes/Relationship"));
const get_where_fields_1 = __importDefault(require("./get-where-fields"));
const pagination_1 = require("./pagination");
const validation_1 = require("./validation");
const constants = __importStar(require("../constants"));
const parse_node_directive_1 = __importDefault(require("./parse-node-directive"));
function makeAugmentedSchema(_a, { enableRegex, skipValidateTypeDefs } = {}) {
    var { typeDefs } = _a, schemaDefinition = __rest(_a, ["typeDefs"]);
    const document = merge_1.mergeTypeDefs(Array.isArray(typeDefs) ? typeDefs : [typeDefs]);
    if (!skipValidateTypeDefs) {
        validation_1.validateDocument(document);
    }
    const composer = new graphql_compose_1.SchemaComposer();
    // graphql-compose will break if the Point and CartesianPoint types are created but not used,
    // because it will purge the unused types but leave behind orphaned field resolvers
    //
    // These are flags to check whether the types are used and then create them if they are
    let pointInTypeDefs = false;
    let cartesianPointInTypeDefs = false;
    const relationships = [];
    composer.createObjectTC({
        name: "CreateInfo",
        fields: {
            bookmark: graphql_1.GraphQLString,
            nodesCreated: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            relationshipsCreated: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
        },
    });
    composer.createObjectTC({
        name: "DeleteInfo",
        fields: {
            bookmark: graphql_1.GraphQLString,
            nodesDeleted: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            relationshipsDeleted: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
        },
    });
    composer.createObjectTC({
        name: "UpdateInfo",
        fields: {
            bookmark: graphql_1.GraphQLString,
            nodesCreated: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            nodesDeleted: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            relationshipsCreated: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            relationshipsDeleted: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
        },
    });
    const composeInt = {
        type: "Int!",
        resolve: resolvers_1.numericalResolver,
        args: {},
    };
    const composeFloat = {
        type: "Float!",
        resolve: resolvers_1.numericalResolver,
        args: {},
    };
    const composeId = {
        type: "ID!",
        resolve: resolvers_1.idResolver,
        args: {},
    };
    const whereAggregationOperators = ["EQUAL", "GT", "GTE", "LT", "LTE"];
    // Types that you can average
    // https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg
    // https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg-duration
    // String uses avg(size())
    const whereAggregationAverageTypes = ["String", "Int", "Float", "BigInt", "Duration"];
    const whereAggregationTypes = [
        "ID",
        "String",
        "Float",
        "Int",
        "BigInt",
        "DateTime",
        "LocalDateTime",
        "LocalTime",
        "Time",
        "Duration",
    ];
    // Foreach i if i[1] is ? then we will assume it takes on type { min, max }
    const aggregationSelectionTypeMatrix = [
        [
            "ID",
            {
                shortest: composeId,
                longest: composeId,
            },
        ],
        [
            "String",
            {
                shortest: "String!",
                longest: "String!",
            },
        ],
        [
            "Float",
            {
                max: composeFloat,
                min: composeFloat,
                average: composeFloat,
            },
        ],
        [
            "Int",
            {
                max: composeInt,
                min: composeInt,
                average: composeFloat,
            },
        ],
        [
            "BigInt",
            {
                max: "BigInt!",
                min: "BigInt!",
                average: "BigInt!",
            },
        ],
        ["DateTime"],
        ["LocalDateTime"],
        ["LocalTime"],
        ["Time"],
        ["Duration"],
    ];
    const aggregationSelectionTypeNames = aggregationSelectionTypeMatrix.map(([name]) => name);
    const aggregationSelectionTypes = aggregationSelectionTypeMatrix.reduce((res, [name, fields]) => {
        return Object.assign(Object.assign({}, res), { [name]: composer.createObjectTC({
                name: `${name}AggregateSelection`,
                fields: fields !== null && fields !== void 0 ? fields : { min: `${name}!`, max: `${name}!` },
            }) });
    }, {});
    const queryOptions = composer.createInputTC({
        name: "QueryOptions",
        fields: {
            offset: "Int",
            limit: "Int",
        },
    });
    const sortDirection = composer.createEnumTC({
        name: "SortDirection",
        values: {
            ASC: {
                value: "ASC",
                description: "Sort by field values in ascending order.",
            },
            DESC: {
                value: "DESC",
                description: "Sort by field values in descending order.",
            },
        },
    });
    composer.createObjectTC({
        name: "PageInfo",
        description: "Pagination information (Relay)",
        fields: {
            hasNextPage: "Boolean!",
            hasPreviousPage: "Boolean!",
            startCursor: "String",
            endCursor: "String",
        },
    });
    const customResolvers = get_custom_resolvers_1.default(document);
    const scalars = document.definitions.filter((x) => x.kind === "ScalarTypeDefinition");
    const objectNodes = document.definitions.filter((x) => x.kind === "ObjectTypeDefinition" && !["Query", "Mutation", "Subscription"].includes(x.name.value));
    const enums = document.definitions.filter((x) => x.kind === "EnumTypeDefinition");
    const inputs = document.definitions.filter((x) => x.kind === "InputObjectTypeDefinition");
    let interfaces = document.definitions.filter((x) => x.kind === "InterfaceTypeDefinition");
    const directives = document.definitions.filter((x) => x.kind === "DirectiveDefinition");
    const unions = document.definitions.filter((x) => x.kind === "UnionTypeDefinition");
    const relationshipPropertyInterfaceNames = new Set();
    const extraDefinitions = [
        ...enums,
        ...scalars,
        ...directives,
        ...inputs,
        ...unions,
        ...[
            customResolvers.customQuery,
            customResolvers.customMutation,
            customResolvers.customSubscription,
        ],
    ].filter(Boolean);
    if (extraDefinitions.length) {
        composer.addTypeDefs(graphql_1.print({ kind: "Document", definitions: extraDefinitions }));
    }
    Object.keys(Scalars).forEach((scalar) => composer.addTypeDefs(`scalar ${scalar}`));
    const nodes = objectNodes.map((definition) => {
        var _a;
        constants.RESERVED_TYPE_NAMES.forEach(([label, message]) => {
            let toThrowError = false;
            if (label === "Connection" && definition.name.value.endsWith("Connection")) {
                toThrowError = true;
            }
            if (definition.name.value === label) {
                toThrowError = true;
            }
            if (toThrowError) {
                throw new Error(message);
            }
        });
        const otherDirectives = (definition.directives || []).filter((x) => !["auth", "exclude", "node"].includes(x.name.value));
        const authDirective = (definition.directives || []).find((x) => x.name.value === "auth");
        const excludeDirective = (definition.directives || []).find((x) => x.name.value === "exclude");
        const nodeDirectiveDefinition = (definition.directives || []).find((x) => x.name.value === "node");
        const nodeInterfaces = [...(definition.interfaces || [])];
        let auth;
        if (authDirective) {
            auth = get_auth_1.default(authDirective);
        }
        let exclude;
        if (excludeDirective) {
            exclude = parse_exclude_directive_1.default(excludeDirective);
        }
        let nodeDirective;
        if (nodeDirectiveDefinition) {
            nodeDirective = parse_node_directive_1.default(nodeDirectiveDefinition);
        }
        const nodeFields = get_obj_field_meta_1.default({
            obj: definition,
            enums,
            interfaces,
            scalars,
            unions,
            objects: objectNodes,
        });
        nodeFields.relationFields.forEach((relationship) => {
            if (relationship.properties) {
                const propertiesInterface = interfaces.find((i) => i.name.value === relationship.properties);
                if (!propertiesInterface) {
                    throw new Error(`Cannot find interface specified in ${definition.name.value}.${relationship.fieldName}`);
                }
                relationshipPropertyInterfaceNames.add(relationship.properties);
            }
        });
        if (!pointInTypeDefs) {
            pointInTypeDefs = nodeFields.pointFields.some((field) => field.typeMeta.name === "Point");
        }
        if (!cartesianPointInTypeDefs) {
            cartesianPointInTypeDefs = nodeFields.pointFields.some((field) => field.typeMeta.name === "CartesianPoint");
        }
        const node = new classes_1.Node(Object.assign(Object.assign({ name: definition.name.value, interfaces: nodeInterfaces, otherDirectives }, nodeFields), { 
            // @ts-ignore we can be sure it's defined
            auth,
            // @ts-ignore we can be sure it's defined
            exclude,
            // @ts-ignore we can be sure it's defined
            nodeDirective, description: (_a = definition.description) === null || _a === void 0 ? void 0 : _a.value }));
        return node;
    });
    const relationshipProperties = interfaces.filter((i) => relationshipPropertyInterfaceNames.has(i.name.value));
    interfaces = interfaces.filter((i) => !relationshipPropertyInterfaceNames.has(i.name.value));
    const relationshipFields = new Map();
    relationshipProperties.forEach((relationship) => {
        var _a;
        constants.RESERVED_TYPE_NAMES.forEach(([label, message]) => {
            let toThrowError = false;
            if (label === "Connection" && relationship.name.value.endsWith("Connection")) {
                toThrowError = true;
            }
            if (relationship.name.value === label) {
                toThrowError = true;
            }
            if (toThrowError) {
                throw new Error(message);
            }
        });
        const authDirective = (relationship.directives || []).find((x) => x.name.value === "auth");
        if (authDirective) {
            throw new Error("Cannot have @auth directive on relationship properties interface");
        }
        (_a = relationship.fields) === null || _a === void 0 ? void 0 : _a.forEach((field) => {
            constants.RESERVED_INTERFACE_FIELDS.forEach(([fieldName, message]) => {
                if (field.name.value === fieldName) {
                    throw new Error(message);
                }
            });
            const forbiddenDirectives = ["auth", "relationship", "cypher"];
            forbiddenDirectives.forEach((directive) => {
                const found = (field.directives || []).find((x) => x.name.value === directive);
                if (found) {
                    throw new Error(`Cannot have @${directive} directive on relationship property`);
                }
            });
        });
        const relFields = get_obj_field_meta_1.default({
            enums,
            interfaces,
            objects: objectNodes,
            scalars,
            unions,
            obj: relationship,
        });
        if (!pointInTypeDefs) {
            pointInTypeDefs = relFields.pointFields.some((field) => field.typeMeta.name === "Point");
        }
        if (!cartesianPointInTypeDefs) {
            cartesianPointInTypeDefs = relFields.pointFields.some((field) => field.typeMeta.name === "CartesianPoint");
        }
        relationshipFields.set(relationship.name.value, relFields);
        const objectComposeFields = to_compose_1.objectFieldsToComposeFields(Object.values(relFields).reduce((acc, x) => [...acc, ...x], []));
        const propertiesInterface = composer.createInterfaceTC({
            name: relationship.name.value,
            fields: objectComposeFields,
        });
        composer.createInputTC({
            name: `${relationship.name.value}Sort`,
            fields: propertiesInterface.getFieldNames().reduce((res, f) => {
                return Object.assign(Object.assign({}, res), { [f]: "SortDirection" });
            }, {}),
        });
        composer.createInputTC({
            name: `${relationship.name.value}UpdateInput`,
            fields: [
                ...relFields.primitiveFields.filter((field) => !field.autogenerate && !field.readonly),
                ...relFields.scalarFields,
                ...relFields.enumFields,
                ...relFields.temporalFields.filter((field) => !field.timestamps),
                ...relFields.pointFields,
            ].reduce((res, f) => (Object.assign(Object.assign({}, res), { [f.fieldName]: f.typeMeta.input.update.pretty })), {}),
        });
        const relationshipWhereFields = get_where_fields_1.default({
            typeName: relationship.name.value,
            fields: {
                scalarFields: relFields.scalarFields,
                enumFields: relFields.enumFields,
                temporalFields: relFields.temporalFields,
                pointFields: relFields.pointFields,
                primitiveFields: relFields.primitiveFields,
            },
            enableRegex: enableRegex || false,
        });
        composer.createInputTC({
            name: `${relationship.name.value}Where`,
            fields: relationshipWhereFields,
        });
        composer.createInputTC({
            name: `${relationship.name.value}CreateInput`,
            // TODO - This reduce duplicated when creating node CreateInput - put into shared function?
            fields: [
                ...relFields.primitiveFields.filter((field) => !field.autogenerate),
                ...relFields.scalarFields,
                ...relFields.enumFields,
                ...relFields.temporalFields.filter((field) => !field.timestamps),
                ...relFields.pointFields,
            ].reduce((res, f) => {
                var _a, _b;
                if (((_a = f) === null || _a === void 0 ? void 0 : _a.defaultValue) !== undefined) {
                    const field = {
                        type: f.typeMeta.input.create.pretty,
                        defaultValue: (_b = f) === null || _b === void 0 ? void 0 : _b.defaultValue,
                    };
                    res[f.fieldName] = field;
                }
                else {
                    res[f.fieldName] = f.typeMeta.input.create.pretty;
                }
                return res;
            }, {}),
        });
    });
    if (pointInTypeDefs) {
        // Every field (apart from CRS) in Point needs a custom resolver
        // to deconstruct the point objects we fetch from the database
        composer.createObjectTC(point.point);
        composer.createInputTC(point.pointInput);
        composer.createInputTC(point.pointDistance);
    }
    if (cartesianPointInTypeDefs) {
        // Every field (apart from CRS) in CartesianPoint needs a custom resolver
        // to deconstruct the point objects we fetch from the database
        composer.createObjectTC(point.cartesianPoint);
        composer.createInputTC(point.cartesianPointInput);
        composer.createInputTC(point.cartesianPointDistance);
    }
    unions.forEach((union) => {
        if (union.types && union.types.length) {
            const fields = union.types.reduce((f, type) => {
                f = Object.assign(Object.assign({}, f), { [type.name.value]: `${type.name.value}Where` });
                return f;
            }, {});
            composer.createInputTC({
                name: `${union.name.value}Where`,
                fields,
            });
        }
    });
    nodes.forEach((node) => {
        var _a, _b, _c, _d;
        const nodeFields = to_compose_1.objectFieldsToComposeFields([
            ...node.primitiveFields,
            ...node.cypherFields,
            ...node.enumFields,
            ...node.scalarFields,
            ...node.interfaceFields,
            ...node.objectFields,
            ...node.unionFields,
            ...node.temporalFields,
            ...node.pointFields,
            ...node.ignoredFields,
        ]);
        const composeNode = composer.createObjectTC({
            name: node.name,
            fields: nodeFields,
            description: node.description,
            directives: to_compose_1.graphqlDirectivesToCompose(node.otherDirectives),
            interfaces: node.interfaces.map((x) => x.name.value),
        });
        const sortFields = [
            ...node.primitiveFields,
            ...node.enumFields,
            ...node.scalarFields,
            ...node.temporalFields,
            ...node.pointFields,
        ].reduce((res, f) => {
            return f.typeMeta.array
                ? Object.assign({}, res) : Object.assign(Object.assign({}, res), { [f.fieldName]: sortDirection.getTypeName() });
        }, {});
        if (Object.keys(sortFields).length) {
            const sortInput = composer.createInputTC({
                name: `${node.name}Sort`,
                fields: sortFields,
                description: `Fields to sort ${pluralize_1.default(node.name)} by. The order in which sorts are applied is not guaranteed when specifying many fields in one ${`${node.name}Sort`} object.`,
            });
            composer.createInputTC({
                name: `${node.name}Options`,
                fields: {
                    sort: {
                        description: `Specify one or more ${`${node.name}Sort`} objects to sort ${pluralize_1.default(node.name)} by. The sorts will be applied in the order in which they are arranged in the array.`,
                        type: sortInput.List,
                    },
                    limit: "Int",
                    offset: "Int",
                },
            });
        }
        else {
            composer.createInputTC({
                name: `${node.name}Options`,
                fields: { limit: "Int", offset: "Int" },
            });
        }
        const queryFields = get_where_fields_1.default({
            typeName: node.name,
            enableRegex,
            fields: {
                temporalFields: node.temporalFields,
                enumFields: node.enumFields,
                pointFields: node.pointFields,
                primitiveFields: node.primitiveFields,
                scalarFields: node.scalarFields,
            },
        });
        composer.createObjectTC({
            name: `${node.name}AggregateSelection`,
            fields: Object.assign({ count: composeInt }, [...node.primitiveFields, ...node.temporalFields].reduce((res, field) => {
                if (field.typeMeta.array) {
                    return res;
                }
                if (!aggregationSelectionTypeNames.includes(field.typeMeta.name)) {
                    return res;
                }
                const objectTypeComposer = aggregationSelectionTypes[field.typeMeta.name];
                res[field.fieldName] = objectTypeComposer.NonNull;
                return res;
            }, {})),
        });
        const whereInput = composer.createInputTC({
            name: `${node.name}Where`,
            fields: queryFields,
        });
        const nodeInput = composer.createInputTC({
            name: `${node.name}CreateInput`,
            // TODO - This reduce duplicated when creating relationship CreateInput - put into shared function?
            fields: [
                ...node.primitiveFields,
                ...node.scalarFields,
                ...node.enumFields,
                ...node.temporalFields.filter((field) => !field.timestamps),
                ...node.pointFields,
            ].reduce((res, f) => {
                var _a, _b, _c;
                if ((_a = f) === null || _a === void 0 ? void 0 : _a.autogenerate) {
                    return res;
                }
                if (((_b = f) === null || _b === void 0 ? void 0 : _b.defaultValue) !== undefined) {
                    const field = {
                        type: f.typeMeta.input.create.pretty,
                        defaultValue: (_c = f) === null || _c === void 0 ? void 0 : _c.defaultValue,
                    };
                    res[f.fieldName] = field;
                }
                else {
                    res[f.fieldName] = f.typeMeta.input.create.pretty;
                }
                return res;
            }, {}),
        });
        const nodeUpdateInput = composer.createInputTC({
            name: `${node.name}UpdateInput`,
            fields: [
                ...node.primitiveFields,
                ...node.scalarFields,
                ...node.enumFields,
                ...node.temporalFields.filter((field) => !field.timestamps),
                ...node.pointFields,
            ].reduce((res, f) => {
                var _a;
                return f.readonly || ((_a = f) === null || _a === void 0 ? void 0 : _a.autogenerate)
                    ? res
                    : Object.assign(Object.assign({}, res), { [f.fieldName]: f.typeMeta.input.update.pretty });
            }, {}),
        });
        const nodeDeleteInput = composer.createInputTC({
            name: `${node.name}DeleteInput`,
            fields: {},
        });
        ["Create", "Update"].map((operation) => composer.createObjectTC({
            name: `${operation}${node.getPlural({ camelCase: false })}MutationResponse`,
            fields: {
                info: `${operation}Info!`,
                [node.getPlural({ camelCase: true })]: `[${node.name}!]!`,
            },
        }));
        let nodeConnectInput = undefined;
        let nodeDisconnectInput = undefined;
        let nodeRelationInput = undefined;
        if (node.relationFields.length) {
            [nodeConnectInput, nodeDisconnectInput, nodeRelationInput] = [
                "ConnectInput",
                "DisconnectInput",
                "RelationInput",
            ].map((type) => composer.createInputTC({
                name: `${node.name}${type}`,
                fields: {},
            }));
        }
        node.relationFields.forEach((rel) => {
            let hasNonGeneratedProperties = false;
            let hasNonNullNonGeneratedProperties = false;
            let relFields;
            if (rel.properties) {
                relFields = relationshipFields.get(rel.properties);
                if (relFields) {
                    const nonGeneratedProperties = [
                        ...relFields.primitiveFields.filter((field) => !field.autogenerate),
                        ...relFields.scalarFields,
                        ...relFields.enumFields,
                        ...relFields.temporalFields.filter((field) => !field.timestamps),
                        ...relFields.pointFields,
                    ];
                    hasNonGeneratedProperties = nonGeneratedProperties.length > 0;
                    hasNonNullNonGeneratedProperties = nonGeneratedProperties.some((field) => field.typeMeta.required);
                }
            }
            if (rel.union) {
                const refNodes = nodes.filter((x) => { var _a, _b; return (_b = (_a = rel.union) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b.includes(x.name); });
                composeNode.addFields({
                    [rel.fieldName]: {
                        type: rel.typeMeta.pretty,
                        args: {
                            options: queryOptions.getTypeName(),
                            where: `${rel.typeMeta.name}Where`,
                        },
                    },
                });
                const upperFieldName = graphql_compose_1.upperFirst(rel.fieldName);
                const upperNodeName = graphql_compose_1.upperFirst(node.name);
                const typePrefix = `${upperNodeName}${upperFieldName}`;
                const [unionConnectInput, unionCreateInput, unionDeleteInput, unionDisconnectInput, unionUpdateInput,] = ["Connect", "Create", "Delete", "Disconnect", "Update"].map((operation) => composer.createInputTC({
                    name: `${typePrefix}${operation}Input`,
                    fields: {},
                }));
                const unionCreateFieldInput = composer.createInputTC({
                    name: `${typePrefix}CreateFieldInput`,
                    fields: {},
                });
                refNodes.forEach((n) => {
                    const unionPrefix = `${node.name}${upperFieldName}${n.name}`;
                    const updateField = `${n.name}UpdateInput`;
                    const nodeFieldInputName = `${unionPrefix}FieldInput`;
                    const whereName = `${unionPrefix}ConnectionWhere`;
                    const deleteName = `${unionPrefix}DeleteFieldInput`;
                    const _delete = rel.typeMeta.array ? `[${deleteName}!]` : `${deleteName}`;
                    const disconnectName = `${unionPrefix}DisconnectFieldInput`;
                    const disconnect = rel.typeMeta.array ? `[${disconnectName}!]` : `${disconnectName}`;
                    const connectionUpdateInputName = `${unionPrefix}UpdateConnectionInput`;
                    const createName = `${node.name}${graphql_compose_1.upperFirst(rel.fieldName)}${n.name}CreateFieldInput`;
                    const create = rel.typeMeta.array ? `[${createName}!]` : createName;
                    if (!composer.has(createName)) {
                        composer.createInputTC({
                            name: createName,
                            fields: Object.assign({ node: `${n.name}CreateInput!` }, (hasNonGeneratedProperties
                                ? {
                                    edge: `${rel.properties}CreateInput${hasNonNullNonGeneratedProperties ? `!` : ""}`,
                                }
                                : {})),
                        });
                        unionCreateInput.addFields({
                            [n.name]: nodeFieldInputName,
                        });
                        unionCreateFieldInput.addFields({
                            [n.name]: `[${createName}!]`,
                        });
                    }
                    const connectWhereName = `${n.name}ConnectWhere`;
                    if (!composer.has(connectWhereName)) {
                        composer.createInputTC({
                            name: connectWhereName,
                            fields: {
                                node: `${n.name}Where!`,
                            },
                        });
                    }
                    const connectName = `${unionPrefix}ConnectFieldInput`;
                    const connect = rel.typeMeta.array ? `[${connectName}!]` : `${connectName}`;
                    if (!composer.has(connectName)) {
                        composer.createInputTC({
                            name: connectName,
                            fields: Object.assign(Object.assign({ where: connectWhereName }, (n.relationFields.length
                                ? {
                                    connect: rel.typeMeta.array
                                        ? `[${n.name}ConnectInput!]`
                                        : `${n.name}ConnectInput`,
                                }
                                : {})), (hasNonGeneratedProperties
                                ? {
                                    edge: `${rel.properties}CreateInput${hasNonNullNonGeneratedProperties ? `!` : ""}`,
                                }
                                : {})),
                        });
                        unionConnectInput.addFields({
                            [n.name]: connect,
                        });
                    }
                    const updateName = `${unionPrefix}UpdateFieldInput`;
                    const update = rel.typeMeta.array ? `[${updateName}!]` : updateName;
                    if (!composer.has(updateName)) {
                        composer.createInputTC({
                            name: updateName,
                            fields: {
                                where: whereName,
                                update: connectionUpdateInputName,
                                connect,
                                disconnect: rel.typeMeta.array ? `[${disconnectName}!]` : disconnectName,
                                create,
                                delete: rel.typeMeta.array ? `[${deleteName}!]` : deleteName,
                            },
                        });
                        unionUpdateInput.addFields({
                            [n.name]: update,
                        });
                    }
                    composer.createInputTC({
                        name: connectionUpdateInputName,
                        fields: Object.assign(Object.assign({}, (hasNonGeneratedProperties ? { edge: `${rel.properties}UpdateInput` } : {})), { node: updateField }),
                    });
                    composer.createInputTC({
                        name: nodeFieldInputName,
                        fields: {
                            create,
                            connect,
                        },
                    });
                    composer.createInputTC({
                        name: whereName,
                        fields: Object.assign({ node: `${n.name}Where`, node_NOT: `${n.name}Where`, AND: `[${whereName}!]`, OR: `[${whereName}!]` }, (rel.properties
                            ? {
                                edge: `${rel.properties}Where`,
                                edge_NOT: `${rel.properties}Where`,
                            }
                            : {})),
                    });
                    if (!composer.has(deleteName)) {
                        composer.createInputTC({
                            name: deleteName,
                            fields: Object.assign({ where: whereName }, (n.relationFields.length
                                ? {
                                    delete: `${n.name}DeleteInput`,
                                }
                                : {})),
                        });
                        unionDeleteInput.addFields({
                            [n.name]: _delete,
                        });
                    }
                    if (!composer.has(disconnectName)) {
                        composer.createInputTC({
                            name: disconnectName,
                            fields: Object.assign({ where: whereName }, (n.relationFields.length
                                ? {
                                    disconnect: `${n.name}DisconnectInput`,
                                }
                                : {})),
                        });
                        unionDisconnectInput.addFields({
                            [n.name]: disconnect,
                        });
                    }
                });
                nodeInput.addFields({
                    [rel.fieldName]: unionCreateInput,
                });
                nodeRelationInput.addFields({
                    [rel.fieldName]: unionCreateFieldInput,
                });
                nodeUpdateInput.addFields({
                    [rel.fieldName]: unionUpdateInput,
                });
                nodeConnectInput.addFields({
                    [rel.fieldName]: unionConnectInput,
                });
                nodeDeleteInput.addFields({
                    [rel.fieldName]: unionDeleteInput,
                });
                nodeDisconnectInput.addFields({
                    [rel.fieldName]: unionDisconnectInput,
                });
                return;
            }
            const n = nodes.find((x) => x.name === rel.typeMeta.name);
            const updateField = `${n.name}UpdateInput`;
            const nodeFieldInputName = `${node.name}${graphql_compose_1.upperFirst(rel.fieldName)}FieldInput`;
            const nodeFieldUpdateInputName = `${node.name}${graphql_compose_1.upperFirst(rel.fieldName)}UpdateFieldInput`;
            const nodeFieldDeleteInputName = `${node.name}${graphql_compose_1.upperFirst(rel.fieldName)}DeleteFieldInput`;
            const nodeFieldDisconnectInputName = `${node.name}${graphql_compose_1.upperFirst(rel.fieldName)}DisconnectFieldInput`;
            const connectionUpdateInputName = `${node.name}${graphql_compose_1.upperFirst(rel.fieldName)}UpdateConnectionInput`;
            const relationshipWhereTypeInputName = `${node.name}${graphql_compose_1.upperFirst(rel.fieldName)}AggregateInput`;
            const [nodeWhereAggregationInput, edgeWhereAggregationInput] = [n, relFields].map((nodeOrRelFields) => {
                if (!nodeOrRelFields) {
                    return;
                }
                const fields = whereAggregationTypes.reduce((r, t) => {
                    const fields = [...nodeOrRelFields.primitiveFields, ...nodeOrRelFields.temporalFields].filter((y) => !y.typeMeta.array && y.typeMeta.name === t);
                    if (!fields.length) {
                        return r;
                    }
                    return r.concat(fields);
                }, []);
                if (!fields.length) {
                    return;
                }
                const name = `${node.name}${graphql_compose_1.upperFirst(rel.fieldName)}${nodeOrRelFields instanceof classes_1.Node ? `Node` : `Edge`}AggregationWhereInput`;
                const aggregationInput = composer.createInputTC({
                    name,
                    fields: {
                        AND: `[${name}!]`,
                        OR: `[${name}!]`,
                    },
                });
                fields.forEach((field) => {
                    if (field.typeMeta.name === "ID") {
                        aggregationInput.addFields({
                            [`${field.fieldName}_EQUAL`]: "ID",
                        });
                        return;
                    }
                    if (field.typeMeta.name === "String") {
                        aggregationInput.addFields(whereAggregationOperators.reduce((res, operator) => {
                            return Object.assign(Object.assign({}, res), { [`${field.fieldName}_${operator}`]: `${operator === "EQUAL" ? "String" : "Int"}`, [`${field.fieldName}_AVERAGE_${operator}`]: "Float", [`${field.fieldName}_LONGEST_${operator}`]: "Int", [`${field.fieldName}_SHORTEST_${operator}`]: "Int" });
                        }, {}));
                        return;
                    }
                    if (whereAggregationAverageTypes.includes(field.typeMeta.name)) {
                        aggregationInput.addFields(whereAggregationOperators.reduce((res, operator) => {
                            let averageType = "Float";
                            if (field.typeMeta.name === "BigInt") {
                                averageType = "BigInt";
                            }
                            if (field.typeMeta.name === "Duration") {
                                averageType = "Duration";
                            }
                            return Object.assign(Object.assign({}, res), { [`${field.fieldName}_${operator}`]: field.typeMeta.name, [`${field.fieldName}_AVERAGE_${operator}`]: averageType, [`${field.fieldName}_MIN_${operator}`]: field.typeMeta.name, [`${field.fieldName}_MAX_${operator}`]: field.typeMeta.name });
                        }, {}));
                        return;
                    }
                    aggregationInput.addFields(whereAggregationOperators.reduce((res, operator) => (Object.assign(Object.assign({}, res), { [`${field.fieldName}_${operator}`]: field.typeMeta.name, [`${field.fieldName}_MIN_${operator}`]: field.typeMeta.name, [`${field.fieldName}_MAX_${operator}`]: field.typeMeta.name })), {}));
                });
                return aggregationInput;
            });
            const whereAggregateInput = composer.createInputTC({
                name: relationshipWhereTypeInputName,
                fields: Object.assign(Object.assign({ count: "Int", count_LT: "Int", count_LTE: "Int", count_GT: "Int", count_GTE: "Int", AND: `[${relationshipWhereTypeInputName}!]`, OR: `[${relationshipWhereTypeInputName}!]` }, (nodeWhereAggregationInput ? { node: nodeWhereAggregationInput } : {})), (edgeWhereAggregationInput ? { edge: edgeWhereAggregationInput } : {})),
            });
            whereInput.addFields({
                [rel.fieldName]: `${n.name}Where`,
                [`${rel.fieldName}_NOT`]: `${n.name}Where`,
                [`${rel.fieldName}Aggregate`]: whereAggregateInput,
            });
            const createName = `${node.name}${graphql_compose_1.upperFirst(rel.fieldName)}CreateFieldInput`;
            const create = rel.typeMeta.array ? `[${createName}!]` : createName;
            if (!composer.has(createName)) {
                composer.createInputTC({
                    name: createName,
                    fields: Object.assign({ node: `${n.name}CreateInput!` }, (hasNonGeneratedProperties
                        ? { edge: `${rel.properties}CreateInput${hasNonNullNonGeneratedProperties ? `!` : ""}` }
                        : {})),
                });
            }
            const connectWhereName = `${n.name}ConnectWhere`;
            if (!composer.has(connectWhereName)) {
                composer.createInputTC({
                    name: connectWhereName,
                    fields: {
                        node: `${n.name}Where!`,
                    },
                });
            }
            const connectName = `${node.name}${graphql_compose_1.upperFirst(rel.fieldName)}ConnectFieldInput`;
            const connect = rel.typeMeta.array ? `[${connectName}!]` : connectName;
            if (!composer.has(connectName)) {
                composer.createInputTC({
                    name: connectName,
                    fields: Object.assign(Object.assign({ where: connectWhereName }, (n.relationFields.length
                        ? { connect: rel.typeMeta.array ? `[${n.name}ConnectInput!]` : `${n.name}ConnectInput` }
                        : {})), (hasNonGeneratedProperties
                        ? { edge: `${rel.properties}CreateInput${hasNonNullNonGeneratedProperties ? `!` : ""}` }
                        : {})),
                });
            }
            composeNode.addFields({
                [rel.fieldName]: {
                    type: rel.typeMeta.pretty,
                    args: {
                        where: `${rel.typeMeta.name}Where`,
                        options: `${rel.typeMeta.name}Options`,
                    },
                },
            });
            composer.createInputTC({
                name: connectionUpdateInputName,
                fields: Object.assign({ node: updateField }, (hasNonGeneratedProperties ? { edge: `${rel.properties}UpdateInput` } : {})),
            });
            composer.createInputTC({
                name: nodeFieldUpdateInputName,
                fields: {
                    where: `${node.name}${graphql_compose_1.upperFirst(rel.fieldName)}ConnectionWhere`,
                    update: connectionUpdateInputName,
                    connect,
                    disconnect: rel.typeMeta.array
                        ? `[${nodeFieldDisconnectInputName}!]`
                        : nodeFieldDisconnectInputName,
                    create,
                    delete: rel.typeMeta.array ? `[${nodeFieldDeleteInputName}!]` : nodeFieldDeleteInputName,
                },
            });
            composer.createInputTC({
                name: nodeFieldInputName,
                fields: {
                    create,
                    connect,
                },
            });
            if (!composer.has(nodeFieldDeleteInputName)) {
                composer.createInputTC({
                    name: nodeFieldDeleteInputName,
                    fields: Object.assign({ where: `${node.name}${graphql_compose_1.upperFirst(rel.fieldName)}ConnectionWhere` }, (n.relationFields.length ? { delete: `${n.name}DeleteInput` } : {})),
                });
            }
            if (!composer.has(nodeFieldDisconnectInputName)) {
                composer.createInputTC({
                    name: nodeFieldDisconnectInputName,
                    fields: Object.assign({ where: `${node.name}${graphql_compose_1.upperFirst(rel.fieldName)}ConnectionWhere` }, (n.relationFields.length ? { disconnect: `${n.name}DisconnectInput` } : {})),
                });
            }
            nodeRelationInput.addFields({
                [rel.fieldName]: create,
            });
            nodeInput.addFields({
                [rel.fieldName]: nodeFieldInputName,
            });
            nodeUpdateInput.addFields({
                [rel.fieldName]: rel.typeMeta.array ? `[${nodeFieldUpdateInputName}!]` : nodeFieldUpdateInputName,
            });
            nodeDeleteInput.addFields({
                [rel.fieldName]: rel.typeMeta.array ? `[${nodeFieldDeleteInputName}!]` : nodeFieldDeleteInputName,
            });
            nodeConnectInput.addFields({
                [rel.fieldName]: connect,
            });
            nodeDisconnectInput.addFields({
                [rel.fieldName]: rel.typeMeta.array
                    ? `[${nodeFieldDisconnectInputName}!]`
                    : nodeFieldDisconnectInputName,
            });
        });
        node.connectionFields.forEach((connectionField) => {
            const relationship = composer.createObjectTC({
                name: connectionField.relationshipTypeName,
                fields: {
                    cursor: "String!",
                    node: `${connectionField.relationship.typeMeta.name}!`,
                },
            });
            const connectionWhereName = `${connectionField.typeMeta.name}Where`;
            const connectionWhere = composer.createInputTC({
                name: connectionWhereName,
                fields: {},
            });
            if (!connectionField.relationship.union) {
                connectionWhere.addFields({
                    AND: `[${connectionWhereName}!]`,
                    OR: `[${connectionWhereName}!]`,
                });
            }
            const connection = composer.createObjectTC({
                name: connectionField.typeMeta.name,
                fields: {
                    edges: relationship.NonNull.List.NonNull,
                    totalCount: "Int!",
                    pageInfo: "PageInfo!",
                },
            });
            if (connectionField.relationship.properties && !connectionField.relationship.union) {
                const propertiesInterface = composer.getIFTC(connectionField.relationship.properties);
                relationship.addInterface(propertiesInterface);
                relationship.addFields(propertiesInterface.getFields());
                connectionWhere.addFields({
                    edge: `${connectionField.relationship.properties}Where`,
                    edge_NOT: `${connectionField.relationship.properties}Where`,
                });
            }
            whereInput.addFields({
                [connectionField.fieldName]: connectionWhere,
                [`${connectionField.fieldName}_NOT`]: connectionWhere,
            });
            let composeNodeArgs = {
                where: connectionWhere,
            };
            if (connectionField.relationship.union) {
                const relatedNodes = nodes.filter((n) => { var _a, _b; return (_b = (_a = connectionField.relationship.union) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b.includes(n.name); });
                relatedNodes.forEach((n) => {
                    const unionWhereName = `${connectionField.typeMeta.name}${n.name}Where`;
                    const unionWhere = composer.createInputTC({
                        name: unionWhereName,
                        fields: {
                            OR: `[${unionWhereName}]`,
                            AND: `[${unionWhereName}]`,
                        },
                    });
                    unionWhere.addFields({
                        node: `${n.name}Where`,
                        node_NOT: `${n.name}Where`,
                    });
                    if (connectionField.relationship.properties) {
                        const propertiesInterface = composer.getIFTC(connectionField.relationship.properties);
                        relationship.addInterface(propertiesInterface);
                        relationship.addFields(propertiesInterface.getFields());
                        unionWhere.addFields({
                            edge: `${connectionField.relationship.properties}Where`,
                            edge_NOT: `${connectionField.relationship.properties}Where`,
                        });
                    }
                    connectionWhere.addFields({
                        [n.name]: unionWhere,
                    });
                });
            }
            else {
                const relatedNode = nodes.find((n) => n.name === connectionField.relationship.typeMeta.name);
                connectionWhere.addFields({
                    node: `${connectionField.relationship.typeMeta.name}Where`,
                    node_NOT: `${connectionField.relationship.typeMeta.name}Where`,
                });
                const connectionSort = composer.createInputTC({
                    name: `${connectionField.typeMeta.name}Sort`,
                    fields: {},
                });
                const nodeSortFields = [
                    ...relatedNode.primitiveFields,
                    ...relatedNode.enumFields,
                    ...relatedNode.scalarFields,
                    ...relatedNode.temporalFields,
                    ...relatedNode.pointFields,
                ].filter((f) => !f.typeMeta.array);
                if (nodeSortFields.length) {
                    connectionSort.addFields({
                        node: `${connectionField.relationship.typeMeta.name}Sort`,
                    });
                }
                if (connectionField.relationship.properties) {
                    connectionSort.addFields({
                        edge: `${connectionField.relationship.properties}Sort`,
                    });
                }
                composeNodeArgs = Object.assign(Object.assign({}, composeNodeArgs), { first: {
                        type: "Int",
                    }, after: {
                        type: "String",
                    } });
                // If any sortable fields, add sort argument to connection field
                if (nodeSortFields.length || connectionField.relationship.properties) {
                    composeNodeArgs = Object.assign(Object.assign({}, composeNodeArgs), { sort: connectionSort.NonNull.List });
                }
            }
            composeNode.addFields({
                [connectionField.fieldName]: {
                    type: connection.NonNull,
                    args: composeNodeArgs,
                    resolve: (source, args, ctx, info) => {
                        return pagination_1.connectionFieldResolver({
                            connectionField,
                            args,
                            info,
                            source,
                        });
                    },
                },
            });
            const relFields = connectionField.relationship.properties
                ? relationshipFields.get(connectionField.relationship.properties)
                : {};
            const r = new Relationship_1.default(Object.assign({ name: connectionField.relationshipTypeName, type: connectionField.relationship.type, properties: connectionField.relationship.properties }, (relFields
                ? {
                    temporalFields: relFields.temporalFields,
                    scalarFields: relFields.scalarFields,
                    primitiveFields: relFields.primitiveFields,
                    pointFields: relFields.pointFields,
                    ignoredFields: relFields.ignoredFields,
                }
                : {})));
            relationships.push(r);
        });
        if (!((_a = node.exclude) === null || _a === void 0 ? void 0 : _a.operations.includes("read"))) {
            composer.Query.addFields({
                [node.getPlural({ camelCase: true })]: resolvers_1.findResolver({ node }),
            });
            composer.Query.addFields({
                [`${node.getPlural({ camelCase: true })}Count`]: resolvers_1.countResolver({ node }),
            });
            composer.Query.addFields({
                [`${node.getPlural({ camelCase: true })}Aggregate`]: resolvers_1.aggregateResolver({ node }),
            });
        }
        if (!((_b = node.exclude) === null || _b === void 0 ? void 0 : _b.operations.includes("create"))) {
            composer.Mutation.addFields({
                [`create${node.getPlural({ camelCase: false })}`]: resolvers_1.createResolver({ node }),
            });
        }
        if (!((_c = node.exclude) === null || _c === void 0 ? void 0 : _c.operations.includes("delete"))) {
            composer.Mutation.addFields({
                [`delete${node.getPlural({ camelCase: false })}`]: resolvers_1.deleteResolver({ node }),
            });
        }
        if (!((_d = node.exclude) === null || _d === void 0 ? void 0 : _d.operations.includes("update"))) {
            composer.Mutation.addFields({
                [`update${node.getPlural({ camelCase: false })}`]: resolvers_1.updateResolver({ node }),
            });
        }
    });
    ["Mutation", "Query"].forEach((type) => {
        const objectComposer = composer[type];
        const cypherType = customResolvers[`customCypher${type}`];
        if (cypherType) {
            const objectFields = get_obj_field_meta_1.default({
                obj: cypherType,
                scalars,
                enums,
                interfaces,
                unions,
                objects: objectNodes,
            });
            const objectComposeFields = to_compose_1.objectFieldsToComposeFields([
                ...objectFields.enumFields,
                ...objectFields.interfaceFields,
                ...objectFields.primitiveFields,
                ...objectFields.relationFields,
                ...objectFields.scalarFields,
                ...objectFields.unionFields,
                ...objectFields.objectFields,
                ...objectFields.temporalFields,
            ]);
            objectComposer.addFields(objectComposeFields);
            objectFields.cypherFields.forEach((field) => {
                const customResolver = resolvers_1.cypherResolver({
                    field,
                    statement: field.statement,
                    type: type,
                });
                const composedField = to_compose_1.objectFieldsToComposeFields([field])[field.fieldName];
                objectComposer.addFields({ [field.fieldName]: Object.assign(Object.assign({}, composedField), customResolver) });
            });
        }
    });
    interfaces.forEach((inter) => {
        var _a;
        const objectFields = get_obj_field_meta_1.default({ obj: inter, scalars, enums, interfaces, unions, objects: objectNodes });
        const objectComposeFields = to_compose_1.objectFieldsToComposeFields(Object.values(objectFields).reduce((acc, x) => [...acc, ...x], []));
        composer.createInterfaceTC({
            name: inter.name.value,
            description: (_a = inter.description) === null || _a === void 0 ? void 0 : _a.value,
            fields: objectComposeFields,
            directives: to_compose_1.graphqlDirectivesToCompose((inter.directives || []).filter((x) => x.name.value !== "auth")),
        });
    });
    if (!Object.values(composer.Mutation.getFields()).length) {
        composer.delete("Mutation");
    }
    const generatedTypeDefs = composer.toSDL();
    let parsedDoc = graphql_1.parse(generatedTypeDefs);
    // @ts-ignore
    const documentNames = parsedDoc.definitions.filter((x) => "name" in x).map((x) => x.name.value);
    const generatedResolvers = Object.assign(Object.assign({}, Object.entries(composer.getResolveMethods()).reduce((res, [key, value]) => {
        if (!documentNames.includes(key)) {
            return res;
        }
        return Object.assign(Object.assign({}, res), { [key]: value });
    }, {})), Object.entries(Scalars).reduce((res, [name, scalar]) => {
        if (generatedTypeDefs.includes(`scalar ${name}\n`)) {
            res[name] = scalar;
        }
        return res;
    }, {}));
    unions.forEach((union) => {
        if (!generatedResolvers[union.name.value]) {
            // eslint-disable-next-line no-underscore-dangle
            generatedResolvers[union.name.value] = { __resolveType: (root) => root.__resolveType };
        }
    });
    const seen = {};
    parsedDoc = Object.assign(Object.assign({}, parsedDoc), { definitions: parsedDoc.definitions.filter((definition) => {
            var _a;
            if (!("name" in definition)) {
                return true;
            }
            const n = (_a = definition.name) === null || _a === void 0 ? void 0 : _a.value;
            if (seen[n]) {
                return false;
            }
            seen[n] = n;
            return true;
        }) });
    const schema = schema_1.makeExecutableSchema(Object.assign(Object.assign({}, schemaDefinition), { typeDefs: parsedDoc, resolvers: generatedResolvers }));
    // Assign a default field resolver to account for aliasing of fields
    utils_1.forEachField(schema, (field) => {
        if (!field.resolve) {
            // eslint-disable-next-line no-param-reassign
            field.resolve = resolvers_1.defaultFieldResolver;
        }
    });
    return {
        nodes,
        relationships,
        schema,
    };
}
exports.default = makeAugmentedSchema;
//# sourceMappingURL=make-augmented-schema.js.map
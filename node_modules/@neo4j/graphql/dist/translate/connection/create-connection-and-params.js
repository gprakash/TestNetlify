"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_relay_1 = require("graphql-relay");
// eslint-disable-next-line import/no-cycle
const create_projection_and_params_1 = __importDefault(require("../create-projection-and-params"));
const create_relationship_property_element_1 = __importDefault(require("../projection/elements/create-relationship-property-element"));
const create_connection_where_and_params_1 = __importDefault(require("../where/create-connection-where-and-params"));
const create_auth_and_params_1 = __importDefault(require("../create-auth-and-params"));
const constants_1 = require("../../constants");
const pagination_1 = require("../../schema/pagination");
function createConnectionAndParams({ resolveTree, field, context, nodeVariable, parameterPrefix, }) {
    var _a, _b;
    let globalParams = {};
    let nestedConnectionFieldParams;
    const subquery = ["CALL {", `WITH ${nodeVariable}`];
    const sortInput = resolveTree.args.sort;
    const afterInput = resolveTree.args.after;
    const firstInput = resolveTree.args.first;
    const whereInput = resolveTree.args.where;
    const relationshipVariable = `${nodeVariable}_${field.relationship.type.toLowerCase()}_relationship`;
    const relationship = context.neoSchema.relationships.find((r) => r.name === field.relationshipTypeName);
    const inStr = field.relationship.direction === "IN" ? "<-" : "-";
    const relTypeStr = `[${relationshipVariable}:${field.relationship.type}]`;
    const outStr = field.relationship.direction === "OUT" ? "->" : "-";
    let relationshipProperties = [];
    let node;
    const connection = resolveTree.fieldsByTypeName[field.typeMeta.name];
    if (connection.edges) {
        const relationshipFieldsByTypeName = connection.edges.fieldsByTypeName[field.relationshipTypeName];
        relationshipProperties = Object.values(relationshipFieldsByTypeName).filter((v) => v.name !== "node");
        node = Object.values(relationshipFieldsByTypeName).find((v) => v.name === "node");
    }
    const elementsToCollect = [];
    if (relationshipProperties.length) {
        const relationshipPropertyEntries = relationshipProperties
            .filter((p) => p.name !== "cursor")
            .map((v) => create_relationship_property_element_1.default({ resolveTree: v, relationship, relationshipVariable }));
        elementsToCollect.push(relationshipPropertyEntries.join(", "));
    }
    if (field.relationship.union) {
        const unionNodes = context.neoSchema.nodes.filter((n) => { var _a, _b; return (_b = (_a = field.relationship.union) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b.includes(n.name); });
        const unionSubqueries = [];
        unionNodes.forEach((n) => {
            var _a, _b;
            if (!whereInput || Object.prototype.hasOwnProperty.call(whereInput, n.name)) {
                const labels = n.labelString;
                const relatedNodeVariable = `${nodeVariable}_${n.name}`;
                const nodeOutStr = `(${relatedNodeVariable}${labels})`;
                const unionSubquery = [];
                const unionSubqueryElementsToCollect = [...elementsToCollect];
                const nestedSubqueries = [];
                if (node) {
                    const nodeFieldsByTypeName = {
                        [n.name]: Object.assign(Object.assign({}, node === null || node === void 0 ? void 0 : node.fieldsByTypeName[n.name]), node === null || node === void 0 ? void 0 : node.fieldsByTypeName[field.relationship.typeMeta.name]),
                    };
                    const nodeProjectionAndParams = create_projection_and_params_1.default({
                        fieldsByTypeName: nodeFieldsByTypeName,
                        node: n,
                        context,
                        varName: relatedNodeVariable,
                        literalElements: true,
                        resolveType: true,
                    });
                    const [nodeProjection, nodeProjectionParams] = nodeProjectionAndParams;
                    unionSubqueryElementsToCollect.push(`node: ${nodeProjection}`);
                    globalParams = Object.assign(Object.assign({}, globalParams), nodeProjectionParams);
                    if ((_b = (_a = nodeProjectionAndParams[2]) === null || _a === void 0 ? void 0 : _a.connectionFields) === null || _b === void 0 ? void 0 : _b.length) {
                        nodeProjectionAndParams[2].connectionFields.forEach((connectionResolveTree) => {
                            const connectionField = n.connectionFields.find((x) => x.fieldName === connectionResolveTree.name);
                            const nestedConnection = createConnectionAndParams({
                                resolveTree: connectionResolveTree,
                                field: connectionField,
                                context,
                                nodeVariable: relatedNodeVariable,
                                parameterPrefix: `${parameterPrefix ? `${parameterPrefix}.` : `${nodeVariable}_`}${resolveTree.alias}.edges.node`,
                            });
                            nestedSubqueries.push(nestedConnection[0]);
                            globalParams = Object.assign(Object.assign({}, globalParams), Object.entries(nestedConnection[1]).reduce((res, [k, v]) => {
                                if (k !== `${relatedNodeVariable}_${connectionResolveTree.alias}`) {
                                    res[k] = v;
                                }
                                return res;
                            }, {}));
                            if (nestedConnection[1][`${relatedNodeVariable}_${connectionResolveTree.alias}`]) {
                                if (!nestedConnectionFieldParams)
                                    nestedConnectionFieldParams = {};
                                nestedConnectionFieldParams = Object.assign(Object.assign({}, nestedConnectionFieldParams), {
                                    [connectionResolveTree.alias]: nestedConnection[1][`${relatedNodeVariable}_${connectionResolveTree.alias}`],
                                });
                            }
                        });
                    }
                }
                else {
                    // This ensures that totalCount calculation is accurate if edges not asked for
                    unionSubqueryElementsToCollect.push(`node: { __resolveType: "${n.name}" }`);
                }
                unionSubquery.push(`WITH ${nodeVariable}`);
                unionSubquery.push(`MATCH (${nodeVariable})${inStr}${relTypeStr}${outStr}${nodeOutStr}`);
                const allowAndParams = create_auth_and_params_1.default({
                    operation: "READ",
                    entity: n,
                    context,
                    allow: {
                        parentNode: n,
                        varName: relatedNodeVariable,
                    },
                });
                if (allowAndParams[0]) {
                    globalParams = Object.assign(Object.assign({}, globalParams), allowAndParams[1]);
                    unionSubquery.push(`CALL apoc.util.validate(NOT(${allowAndParams[0]}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`);
                }
                const whereStrs = [];
                const unionWhere = (whereInput || {})[n.name];
                if (unionWhere) {
                    const where = create_connection_where_and_params_1.default({
                        whereInput: unionWhere,
                        node: n,
                        nodeVariable: relatedNodeVariable,
                        relationship,
                        relationshipVariable,
                        context,
                        parameterPrefix: `${parameterPrefix ? `${parameterPrefix}.` : `${nodeVariable}_`}${resolveTree.alias}.args.where.${n.name}`,
                    });
                    const [whereClause] = where;
                    if (whereClause) {
                        if (whereClause) {
                            whereStrs.push(whereClause);
                        }
                    }
                }
                const whereAuth = create_auth_and_params_1.default({
                    operation: "READ",
                    entity: n,
                    context,
                    where: { varName: relatedNodeVariable, node: n },
                });
                if (whereAuth[0]) {
                    whereStrs.push(whereAuth[0]);
                    globalParams = Object.assign(Object.assign({}, globalParams), whereAuth[1]);
                }
                if (whereStrs.length) {
                    unionSubquery.push(`WHERE ${whereStrs.join(" AND ")}`);
                }
                if (nestedSubqueries.length) {
                    unionSubquery.push(nestedSubqueries.join("\n"));
                }
                unionSubquery.push(`WITH { ${unionSubqueryElementsToCollect.join(", ")} } AS edge`);
                unionSubquery.push("RETURN edge");
                unionSubqueries.push(unionSubquery.join("\n"));
            }
        });
        const unionSubqueryCypher = ["CALL {", unionSubqueries.join("\nUNION\n"), "}"];
        const withValues = [];
        if (!firstInput && !afterInput) {
            if (connection.edges || connection.pageInfo) {
                withValues.push("collect(edge) as edges");
            }
            withValues.push("count(edge) as totalCount");
            unionSubqueryCypher.push(`WITH ${withValues.join(", ")}`);
        }
        else {
            const offsetLimitStr = pagination_1.createOffsetLimitStr({
                offset: typeof afterInput === "string" ? graphql_relay_1.cursorToOffset(afterInput) + 1 : undefined,
                limit: firstInput,
            });
            unionSubqueryCypher.push("WITH collect(edge) AS allEdges");
            unionSubqueryCypher.push(`WITH allEdges, size(allEdges) as totalCount, allEdges${offsetLimitStr} AS edges`);
        }
        subquery.push(unionSubqueryCypher.join("\n"));
    }
    else {
        const relatedNodeVariable = `${nodeVariable}_${field.relationship.typeMeta.name.toLowerCase()}`;
        const relatedNode = context.neoSchema.nodes.find((x) => x.name === field.relationship.typeMeta.name);
        const labels = relatedNode.labelString;
        const nodeOutStr = `(${relatedNodeVariable}${labels})`;
        subquery.push(`MATCH (${nodeVariable})${inStr}${relTypeStr}${outStr}${nodeOutStr}`);
        const whereStrs = [];
        if (whereInput) {
            const where = create_connection_where_and_params_1.default({
                whereInput,
                node: relatedNode,
                nodeVariable: relatedNodeVariable,
                relationship,
                relationshipVariable,
                context,
                parameterPrefix: `${parameterPrefix ? `${parameterPrefix}.` : `${nodeVariable}_`}${resolveTree.alias}.args.where`,
            });
            const [whereClause] = where;
            if (whereClause) {
                whereStrs.push(`${whereClause}`);
            }
        }
        const whereAuth = create_auth_and_params_1.default({
            operation: "READ",
            entity: relatedNode,
            context,
            where: { varName: relatedNodeVariable, node: relatedNode },
        });
        if (whereAuth[0]) {
            whereStrs.push(whereAuth[0]);
            globalParams = Object.assign(Object.assign({}, globalParams), whereAuth[1]);
        }
        if (whereStrs.length) {
            subquery.push(`WHERE ${whereStrs.join(" AND ")}`);
        }
        const allowAndParams = create_auth_and_params_1.default({
            operation: "READ",
            entity: relatedNode,
            context,
            allow: {
                parentNode: relatedNode,
                varName: relatedNodeVariable,
            },
        });
        if (allowAndParams[0]) {
            globalParams = Object.assign(Object.assign({}, globalParams), allowAndParams[1]);
            subquery.push(`CALL apoc.util.validate(NOT(${allowAndParams[0]}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`);
        }
        if (sortInput && sortInput.length) {
            const sort = sortInput.map((s) => [
                ...Object.entries(s.edge || []).map(([f, direction]) => `${relationshipVariable}.${f} ${direction}`),
                ...Object.entries(s.node || []).map(([f, direction]) => `${relatedNodeVariable}.${f} ${direction}`),
            ].join(", "));
            subquery.push(`WITH ${relationshipVariable}, ${relatedNodeVariable}`);
            subquery.push(`ORDER BY ${sort.join(", ")}`);
        }
        const nestedSubqueries = [];
        if (node) {
            const nodeProjectionAndParams = create_projection_and_params_1.default({
                fieldsByTypeName: node === null || node === void 0 ? void 0 : node.fieldsByTypeName,
                node: relatedNode,
                context,
                varName: relatedNodeVariable,
                literalElements: true,
            });
            const [nodeProjection, nodeProjectionParams, projectionMeta] = nodeProjectionAndParams;
            elementsToCollect.push(`node: ${nodeProjection}`);
            globalParams = Object.assign(Object.assign({}, globalParams), nodeProjectionParams);
            if ((_a = projectionMeta === null || projectionMeta === void 0 ? void 0 : projectionMeta.authValidateStrs) === null || _a === void 0 ? void 0 : _a.length) {
                subquery.push(`CALL apoc.util.validate(NOT(${projectionMeta.authValidateStrs.join(" AND ")}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`);
            }
            if ((_b = projectionMeta === null || projectionMeta === void 0 ? void 0 : projectionMeta.connectionFields) === null || _b === void 0 ? void 0 : _b.length) {
                projectionMeta.connectionFields.forEach((connectionResolveTree) => {
                    const connectionField = relatedNode.connectionFields.find((x) => x.fieldName === connectionResolveTree.name);
                    const nestedConnection = createConnectionAndParams({
                        resolveTree: connectionResolveTree,
                        field: connectionField,
                        context,
                        nodeVariable: relatedNodeVariable,
                        parameterPrefix: `${parameterPrefix ? `${parameterPrefix}.` : `${nodeVariable}_`}${resolveTree.alias}.edges.node`,
                    });
                    nestedSubqueries.push(nestedConnection[0]);
                    globalParams = Object.assign(Object.assign({}, globalParams), Object.entries(nestedConnection[1]).reduce((res, [k, v]) => {
                        if (k !== `${relatedNodeVariable}_${connectionResolveTree.alias}`) {
                            res[k] = v;
                        }
                        return res;
                    }, {}));
                    if (nestedConnection[1][`${relatedNodeVariable}_${connectionResolveTree.alias}`]) {
                        if (!nestedConnectionFieldParams)
                            nestedConnectionFieldParams = {};
                        nestedConnectionFieldParams = Object.assign(Object.assign({}, nestedConnectionFieldParams), {
                            [connectionResolveTree.alias]: nestedConnection[1][`${relatedNodeVariable}_${connectionResolveTree.alias}`],
                        });
                    }
                });
            }
        }
        if (nestedSubqueries.length)
            subquery.push(nestedSubqueries.join("\n"));
        subquery.push(`WITH collect({ ${elementsToCollect.join(", ")} }) AS edges`);
    }
    const returnValues = [];
    if (!firstInput && !afterInput) {
        if (connection.edges || connection.pageInfo) {
            returnValues.push("edges: edges");
        }
        returnValues.push(`totalCount: ${field.relationship.union ? "totalCount" : "size(edges)"}`);
        subquery.push(`RETURN { ${returnValues.join(", ")} } AS ${resolveTree.alias}`);
    }
    else {
        const offsetLimitStr = pagination_1.createOffsetLimitStr({
            offset: typeof afterInput === "string" ? graphql_relay_1.cursorToOffset(afterInput) + 1 : undefined,
            limit: firstInput,
        });
        subquery.push(`WITH size(edges) AS totalCount, edges${offsetLimitStr} AS limitedSelection`);
        subquery.push(`RETURN { edges: limitedSelection, totalCount: totalCount } AS ${resolveTree.alias}`);
    }
    subquery.push("}");
    const params = Object.assign(Object.assign({}, globalParams), ((whereInput || nestedConnectionFieldParams) && {
        [`${nodeVariable}_${resolveTree.alias}`]: Object.assign(Object.assign({}, (whereInput && { args: { where: whereInput } })), (nestedConnectionFieldParams && { edges: { node: Object.assign({}, nestedConnectionFieldParams) } })),
    }));
    return [subquery.join("\n"), params];
}
exports.default = createConnectionAndParams;
//# sourceMappingURL=create-connection-and-params.js.map
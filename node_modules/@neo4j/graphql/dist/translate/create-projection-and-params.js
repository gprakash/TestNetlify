"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const create_where_and_params_1 = __importDefault(require("./create-where-and-params"));
const create_auth_and_params_1 = __importDefault(require("./create-auth-and-params"));
const constants_1 = require("../constants");
const create_datetime_element_1 = __importDefault(require("./projection/elements/create-datetime-element"));
const create_point_element_1 = __importDefault(require("./projection/elements/create-point-element"));
// eslint-disable-next-line import/no-cycle
const create_connection_and_params_1 = __importDefault(require("./connection/create-connection-and-params"));
const pagination_1 = require("../schema/pagination");
const map_to_db_property_1 = __importDefault(require("../utils/map-to-db-property"));
function createNodeWhereAndParams({ whereInput, varName, context, node, authValidateStrs, chainStr, }) {
    const whereStrs = [];
    let params = {};
    if (whereInput) {
        const whereAndParams = create_where_and_params_1.default({
            context,
            node,
            varName,
            whereInput,
            chainStr,
            recursing: true,
        });
        if (whereAndParams[0]) {
            whereStrs.push(whereAndParams[0]);
            params = Object.assign(Object.assign({}, params), whereAndParams[1]);
        }
    }
    const whereAuth = create_auth_and_params_1.default({
        entity: node,
        operation: "READ",
        context,
        where: {
            varName,
            chainStr,
            node,
        },
    });
    if (whereAuth[0]) {
        whereStrs.push(whereAuth[0]);
        params = Object.assign(Object.assign({}, params), whereAuth[1]);
    }
    const preAuth = create_auth_and_params_1.default({
        entity: node,
        operation: "READ",
        context,
        allow: {
            parentNode: node,
            varName,
            chainStr,
        },
    });
    if (preAuth[0]) {
        whereStrs.push(`apoc.util.validatePredicate(NOT(${preAuth[0]}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`);
        params = Object.assign(Object.assign({}, params), preAuth[1]);
    }
    if (authValidateStrs === null || authValidateStrs === void 0 ? void 0 : authValidateStrs.length) {
        whereStrs.push(`apoc.util.validatePredicate(NOT(${authValidateStrs.join(" AND ")}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`);
    }
    return [whereStrs.join(" AND "), params];
}
function createProjectionAndParams({ fieldsByTypeName, node, context, chainStr, varName, literalElements, resolveType, inRelationshipProjection, }) {
    var _a;
    function reducer(res, [key, field]) {
        var _a, _b, _c, _d;
        let param = "";
        if (chainStr) {
            param = `${chainStr}_${key}`;
        }
        else {
            param = `${varName}_${key}`;
        }
        const whereInput = field.args.where;
        const optionsInput = field.args.options;
        const fieldFields = field.fieldsByTypeName;
        const cypherField = node.cypherFields.find((x) => x.fieldName === field.name);
        const relationField = node.relationFields.find((x) => x.fieldName === field.name);
        const connectionField = node.connectionFields.find((x) => x.fieldName === field.name);
        const pointField = node.pointFields.find((x) => x.fieldName === field.name);
        const temporalField = node.temporalFields.find((x) => x.fieldName === field.name);
        const authableField = node.authableFields.find((x) => x.fieldName === field.name);
        if (authableField) {
            if (authableField.auth) {
                const allowAndParams = create_auth_and_params_1.default({
                    entity: authableField,
                    operation: "READ",
                    context,
                    allow: { parentNode: node, varName, chainStr: param },
                });
                if (allowAndParams[0]) {
                    if (!res.meta.authValidateStrs) {
                        res.meta.authValidateStrs = [];
                    }
                    (_a = res.meta.authValidateStrs) === null || _a === void 0 ? void 0 : _a.push(allowAndParams[0]);
                    res.params = Object.assign(Object.assign({}, res.params), allowAndParams[1]);
                }
            }
        }
        if (cypherField) {
            let projectionAuthStr = "";
            let projectionStr = "";
            const isPrimitive = ["ID", "String", "Boolean", "Float", "Int", "DateTime", "BigInt"].includes(cypherField.typeMeta.name);
            const isEnum = context.neoSchema.document.definitions.find((x) => x.kind === "EnumTypeDefinition" && x.name.value === cypherField.typeMeta.name);
            const isScalar = context.neoSchema.document.definitions.find((x) => x.kind === "ScalarTypeDefinition" && x.name.value === cypherField.typeMeta.name);
            const referenceNode = context.neoSchema.nodes.find((x) => x.name === cypherField.typeMeta.name);
            if (referenceNode) {
                const recurse = createProjectionAndParams({
                    fieldsByTypeName: fieldFields,
                    node: referenceNode || node,
                    context,
                    varName: `${varName}_${key}`,
                    chainStr: param,
                });
                [projectionStr] = recurse;
                res.params = Object.assign(Object.assign({}, res.params), recurse[1]);
                if ((_c = (_b = recurse[2]) === null || _b === void 0 ? void 0 : _b.authValidateStrs) === null || _c === void 0 ? void 0 : _c.length) {
                    projectionAuthStr = recurse[2].authValidateStrs.join(" AND ");
                }
            }
            const initApocParamsStrs = [
                ...(context.auth ? ["auth: $auth"] : []),
                ...(context.cypherParams ? ["cypherParams: $cypherParams"] : []),
            ];
            const apocParams = Object.entries(field.args).reduce((r, entry) => {
                const argName = `${param}_${entry[0]}`;
                return {
                    strs: [...r.strs, `${entry[0]}: $${argName}`],
                    params: Object.assign(Object.assign({}, r.params), { [argName]: entry[1] }),
                };
            }, { strs: initApocParamsStrs, params: {} });
            res.params = Object.assign(Object.assign(Object.assign({}, res.params), apocParams.params), (context.cypherParams ? { cypherParams: context.cypherParams } : {}));
            const expectMultipleValues = referenceNode && cypherField.typeMeta.array ? "true" : "false";
            const apocWhere = `${projectionAuthStr
                ? `WHERE apoc.util.validatePredicate(NOT(${projectionAuthStr}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`
                : ""}`;
            const apocParamsStr = `{this: ${chainStr || varName}${apocParams.strs.length ? `, ${apocParams.strs.join(", ")}` : ""}}`;
            const apocStr = `${!isPrimitive && !isEnum && !isScalar ? `${param} IN` : ""} apoc.cypher.runFirstColumn("${cypherField.statement}", ${apocParamsStr}, ${expectMultipleValues})${apocWhere ? ` ${apocWhere}` : ""}${projectionStr ? ` | ${param} ${projectionStr}` : ""}`;
            if (isPrimitive || isEnum || isScalar) {
                res.projection.push(`${key}: ${apocStr}`);
                return res;
            }
            if (cypherField.typeMeta.array) {
                res.projection.push(`${key}: [${apocStr}]`);
                return res;
            }
            res.projection.push(`${key}: head([${apocStr}])`);
            return res;
        }
        if (relationField) {
            const referenceNode = context.neoSchema.nodes.find((x) => x.name === relationField.typeMeta.name);
            const nodeMatchStr = `(${chainStr || varName})`;
            const inStr = relationField.direction === "IN" ? "<-" : "-";
            const relTypeStr = `[:${relationField.type}]`;
            const outStr = relationField.direction === "OUT" ? "->" : "-";
            const labels = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.labelString;
            const nodeOutStr = `(${param}${labels})`;
            const isArray = relationField.typeMeta.array;
            if (relationField.union) {
                const referenceNodes = context.neoSchema.nodes.filter((x) => {
                    var _a, _b;
                    return ((_b = (_a = relationField.union) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b.includes(x.name)) &&
                        (!field.args.where || Object.prototype.hasOwnProperty.call(field.args.where, x.name));
                });
                const unionStrs = [
                    `${key}: ${!isArray ? "head(" : ""} [${param} IN [(${chainStr || varName})${inStr}${relTypeStr}${outStr}(${param})`,
                    `WHERE ${referenceNodes
                        .map((x) => {
                        const labelsStatements = x.labels.map((label) => `"${label}" IN labels(${param})`);
                        return `(${labelsStatements.join(" AND ")})`;
                    })
                        .join(" OR ")}`,
                    `| head(`,
                ];
                const headStrs = referenceNodes.map((refNode) => {
                    var _a;
                    const labelsStatements = refNode.labels.map((label) => `"${label}" IN labels(${param})`);
                    const innerHeadStr = [
                        `[ ${param} IN [${param}] WHERE (${labelsStatements.join(" AND ")})`,
                    ];
                    if (field.fieldsByTypeName[refNode.name]) {
                        const recurse = createProjectionAndParams({
                            fieldsByTypeName: field.fieldsByTypeName,
                            node: refNode,
                            context,
                            varName: param,
                        });
                        const nodeWhereAndParams = createNodeWhereAndParams({
                            whereInput: field.args.where ? field.args.where[refNode.name] : field.args.where,
                            context,
                            node: refNode,
                            varName: param,
                            chainStr: `${param}_${refNode.name}`,
                            authValidateStrs: (_a = recurse[2]) === null || _a === void 0 ? void 0 : _a.authValidateStrs,
                        });
                        if (nodeWhereAndParams[0]) {
                            innerHeadStr.push(`AND ${nodeWhereAndParams[0]}`);
                            res.params = Object.assign(Object.assign({}, res.params), nodeWhereAndParams[1]);
                        }
                        innerHeadStr.push([
                            `| ${param} { __resolveType: "${refNode.name}", `,
                            ...recurse[0].replace("{", "").split(""),
                        ].join(""));
                        res.params = Object.assign(Object.assign({}, res.params), recurse[1]);
                    }
                    else {
                        innerHeadStr.push(`| ${param} { __resolveType: "${refNode.name}" } `);
                    }
                    innerHeadStr.push(`]`);
                    return innerHeadStr.join(" ");
                });
                unionStrs.push(headStrs.join(" + "));
                unionStrs.push(`) ] WHERE ${param} IS NOT NULL]`);
                if (optionsInput) {
                    const offsetLimit = pagination_1.createOffsetLimitStr({
                        offset: optionsInput.offset,
                        limit: optionsInput.limit,
                    });
                    if (offsetLimit) {
                        unionStrs.push(offsetLimit);
                    }
                }
                unionStrs.push(`${!isArray ? ")" : ""}`);
                res.projection.push(unionStrs.join(" "));
                return res;
            }
            let projectionStr = "";
            const recurse = createProjectionAndParams({
                fieldsByTypeName: fieldFields,
                node: referenceNode || node,
                context,
                varName: `${varName}_${key}`,
                chainStr: param,
                inRelationshipProjection: true,
            });
            [projectionStr] = recurse;
            res.params = Object.assign(Object.assign({}, res.params), recurse[1]);
            let whereStr = "";
            const nodeWhereAndParams = createNodeWhereAndParams({
                whereInput,
                varName: `${varName}_${key}`,
                node: referenceNode,
                context,
                authValidateStrs: (_d = recurse[2]) === null || _d === void 0 ? void 0 : _d.authValidateStrs,
            });
            if (nodeWhereAndParams[0]) {
                whereStr = `WHERE ${nodeWhereAndParams[0]}`;
                res.params = Object.assign(Object.assign({}, res.params), nodeWhereAndParams[1]);
            }
            const pathStr = `${nodeMatchStr}${inStr}${relTypeStr}${outStr}${nodeOutStr}`;
            const innerStr = `${pathStr}  ${whereStr} | ${param} ${projectionStr}`;
            let nestedQuery;
            if (optionsInput) {
                const offsetLimit = pagination_1.createOffsetLimitStr({ offset: optionsInput.offset, limit: optionsInput.limit });
                if (optionsInput.sort) {
                    const sorts = optionsInput.sort.reduce((s, sort) => {
                        return [
                            ...s,
                            ...Object.entries(sort).map(([fieldName, direction]) => {
                                if (direction === "DESC") {
                                    return `'${fieldName}'`;
                                }
                                return `'^${fieldName}'`;
                            }),
                        ];
                    }, []);
                    nestedQuery = `${key}: apoc.coll.sortMulti([ ${innerStr} ], [${sorts.join(", ")}])${offsetLimit}`;
                }
                else {
                    nestedQuery = `${key}: ${!isArray ? "head(" : ""}[ ${innerStr} ]${offsetLimit}${!isArray ? ")" : ""}`;
                }
            }
            else {
                nestedQuery = `${key}: ${!isArray ? "head(" : ""}[ ${innerStr} ]${!isArray ? ")" : ""}`;
            }
            res.projection.push(nestedQuery);
            return res;
        }
        if (connectionField) {
            if (!inRelationshipProjection) {
                if (!res.meta.connectionFields) {
                    res.meta.connectionFields = [];
                }
                res.meta.connectionFields.push(field);
                res.projection.push(literalElements ? `${field.alias}: ${field.alias}` : `${field.alias}`);
                return res;
            }
            const matchedConnectionField = node.connectionFields.find((x) => x.fieldName === field.name);
            const connection = create_connection_and_params_1.default({
                resolveTree: field,
                field: matchedConnectionField,
                context,
                nodeVariable: varName,
            });
            const connectionParamName = Object.keys(connection[1])[0];
            const runFirstColumnParams = connectionParamName
                ? `{ ${chainStr}: ${chainStr}, ${connectionParamName}: $${connectionParamName} }`
                : `{ ${chainStr}: ${chainStr} }`;
            res.projection.push(`${field.name}: apoc.cypher.runFirstColumn("${connection[0]} RETURN ${field.name}", ${runFirstColumnParams}, false)`);
            res.params = Object.assign(Object.assign({}, res.params), connection[1]);
            return res;
        }
        if (pointField) {
            res.projection.push(create_point_element_1.default({ resolveTree: field, field: pointField, variable: varName }));
        }
        else if ((temporalField === null || temporalField === void 0 ? void 0 : temporalField.typeMeta.name) === "DateTime") {
            res.projection.push(create_datetime_element_1.default({ resolveTree: field, field: temporalField, variable: varName }));
        }
        else {
            // If field is aliased, rename projected field to alias and set to varName.fieldName
            // e.g. RETURN varname { .fieldName } -> RETURN varName { alias: varName.fieldName }
            let aliasedProj;
            if (field.alias !== field.name) {
                aliasedProj = `${field.alias}: ${varName}`;
            }
            else if (literalElements) {
                aliasedProj = `${key}: ${varName}`;
            }
            else {
                aliasedProj = "";
            }
            // In the case of using the @alias directive (map a GraphQL field to a db prop)
            // the output will be RETURN varName {GraphQLfield: varName.dbAlias}
            const dbFieldName = map_to_db_property_1.default(node, field.name);
            if (dbFieldName !== field.name) {
                aliasedProj = !aliasedProj ? `${key}: ${varName}` : aliasedProj;
            }
            res.projection.push(`${aliasedProj}.${dbFieldName}`);
        }
        return res;
    }
    // Include fields of implemented interfaces to allow for fragments on interfaces
    // cf. https://github.com/neo4j/graphql/issues/476
    const fields = ((_a = node.interfaces) !== null && _a !== void 0 ? _a : [])
        // Map over the implemented interfaces of the node and extract the names
        .map((implementedInterface) => implementedInterface.name.value)
        // Combine the fields of the interfaces...
        .reduce((prevFields, interfaceName) => (Object.assign(Object.assign({}, prevFields), fieldsByTypeName[interfaceName])), 
    // with the fields of the node
    fieldsByTypeName[node.name]);
    const { projection, params, meta } = Object.entries(fields).reduce(reducer, {
        projection: resolveType ? [`__resolveType: "${node.name}"`] : [],
        params: {},
        meta: {},
    });
    return [`{ ${projection.join(", ")} }`, params, meta];
}
exports.default = createProjectionAndParams;
//# sourceMappingURL=create-projection-and-params.js.map